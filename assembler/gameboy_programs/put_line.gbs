# **************************************************************************** #
#                                                           LE - /             #
#                                                               /              #
#    put_line.gbs                                     .::    .:/ .      .::    #
#                                                  +:+:+   +:    +:  +:+:+     #
#    By: fcordon <marvin@le-101.fr>                 +:+   +:    +:    +:+      #
#                                                  #+#   #+    #+    #+#       #
#    Created: 2019/09/15 15:26:28 by fcordon      #+#   ##    ##    #+#        #
#    Updated: 2019/09/15 22:25:40 by fcordon     ###    #+. /#+    ###.fr      #
#                                                          /                   #
#                                                         /                    #
# **************************************************************************** #

## Methode

#0,0 -> 1,4
#
#
#4 shifts, W = 1
#if (n_shift > W + 1)
#	n_shift = W + 1
#
#0,0 -> 1,4
#
#1 shift + 1 = 2, W = 1 + 1 = 2
#4 / 2 = 2
#0,0		0,1		1,2		1,3


#start	= {0, 3}
#end		= {5, 1}
#
#
#end.x - start.x < end.x ? ok : swap(end, start)
#
#n_decalage = start.y - end.y
#
#
#
#1) n_decalage = 3 - 1 = 2
#	end.x - start.x = 5 (length)
#	dec_len = length/n_decalage = 2 reste 1
#
#	x = start.x, y = start.y
#	while (length)
#	{
#		tmp = dec_len
#		while (dec_len && length)
#		{
#			put_pixel(x, y)
#			x++
#			length--;
#		}
#		y++ # ou y-- si n_decalage < 0
#		length--
#	}


#1)=====================
#  0 1 2 3 4 5 6 7 8 9
#0
#1           X
#2
#3 X
#4
#5
#
#2)=====================
#  0 1 2 3 4 5 6 7 8 9
#0
#1 X         
#2
#3           X 
#4
#5
#3)=====================
#  0 1 2 3 4 5 6 7 8 9
#0
#1 X         
#2
#3   X         
#4
#5

#
#start	= {0, 3}
#end		= {5, 1}
#
#
#end.x - start.x < end.x ? ok : swap(end, start)
#
#n_decalage = start.y - end.y
#
#
#
#1) n_decalage = 3 - 1 = 2
#	end.x - start.x = 5 (length)
#	dec_len = length/n_decalage = 2 reste 1
#
#	x = start.x, y = start.y
#	while (length)
#	{
#		tmp = dec_len
#		while (dec_len && length)
#		{
#			put_pixel(x, y)
#			x++
#			length--;
#		}
#		y++ # ou y-- si n_decalage < 0
#		length--
#	}
#
#
#2) n_decalage = 1 - 3 = -2
#	end.x - start.x = 5 (length)
#	dec_len = length/n_decalage = -2 reste -1
#
#	x = start.x, y = start.y
#	while (length)
#	{
#		tmp = dec_len
#		while (dec_len && length)
#		{
#			put_pixel(x, y)
#			x++
#			length--;
#		}
#		y--
#		length--
#	}
#


%define n_shift		0xFF80
%define length		0xFF81
%define shift_len	0xFF82
%define	inc_or_dec	0xFF83
%define col			0xFF84

%define	start		HL
%define end			DE
%define neg_color	BC

%define	start_x		H
%define	start_y		L
%define	end_x		D
%define	end_y		E
%define negative	B
%define color		C

_put_line:	##	put_line(start = HL, end = DE, C = color)	# H = start.x, L = start.y, ...
#{
	push	HL
	push	DE
	push	BC

#	ld		A,		C
#	ld		[col],	A
	ld		negative,	1

	## end.x - start.x < 0 ? jrz
	ld		A,	end_x
	sub		A,	start_x
	jpz		__PL_put_vertical_line				## <<<<<<<<<<<<<<<
#	and		0x80				## is negative ?
	jrnc	__PL_no_swap_start_end

	## swap
	push	end
	push	start
	pop		end
	pop		start

	## set n_shift, length and shift_len
	__PL_no_swap_start_end:
	ld		A,	end_y
	sub		A,	start_y
	jrz		__PL_put_horizontal_line			## <<<<<<<<<<<<<<<
#	and		A,	0x80
	jrnc	__PL_next_step
	
	push	AF
	ld		negative,	0xFF
	not		A				## Absolute number (~A + 1)
	inc		A				## Absolute number

	__PL_next_step:
	inc		A			## n_shift++ ?
	ld		[n_shift],	A
	ld		C,			A	## C = diviser
	ld		A,			negative
	ld		[inc_or_dec],	A

	ld		A,	end_x
	sub		A,	start_x		## A = number
	ld		[length],	A

	## div length/n_shift
	call	_div_8
	sla		B					## check if B == 0
	jrz		__PL_no_inc_shift_len
	inc		A
	__PL_no_inc_shift_len:
	ld		[shift_len],	A
	ld		A,				negative
	ld		[inc_or_dec],	A

	


	%define	X			A
	%define Y			C
	%define LENGTH		D
	%define COLOR		E
	%define SHIFT_LEN	B

	pop		DE		## E = color
	push	DE
	ld		A,	[length]
	ld		D,	A
	ld		A,	[shift_len]
	ld		B,	A
	ld		C,	start_y
	ld		A,	start_x


	__PL_put_line:
		push	HL
		push	AF
		call	_put_pixel
		pop		AF
		pop		HL

		dec		LENGTH			## dec D
		jpz		__PL_return
		inc		X				## inc A
		dec		SHIFT_LEN		## dec B
		jrnz	__PL_put_line

	push	AF
	ld		A,	[inc_or_dec]
	cp		0xFF
	jrnz	__PL_inc
	dec		Y
	jr		__PL_after_incrementation
	__PL_inc:
	inc		Y
	__PL_after_incrementation:
	ld		A,	[shift_len]
	ld		B,	A
	pop		AF
	jr		__PL_put_line

	
	

%undef length
%define length	D

__PL_put_vertical_line:
	ld		A,	end_y
	sub		A,	start_y
	jpz		__PL_put_one_px
	jrnc	__PL_no_abs
	not		A
	inc		A
## swap start and end
	push	start
	push	end
	pop		start
	pop		end
	__PL_no_abs:
	pop		DE
	push	DE
	ld		length,		A
	ld		A,			start_x
	ld		C,			start_y

	__PL_vertical_loop:
		push	AF
		push	HL
		call	_put_pixel
		pop		HL
		pop		AF
		inc		C
		dec		length
		jrnz	__PL_vertical_loop
	jr	__PL_return


__PL_put_horizontal_line:
	ld		A,	end_x
	sub		A,	start_x
	pop		DE
	push	DE
	ld		length,	A
	ld		A,	start_x
	ld		C,	start_y

	__PL_horizontal_loop:
		push	AF
		push	HL
		call	_put_pixel
		pop		HL
		pop		AF
		inc		A
		dec		length
		jrnz	__PL_horizontal_loop
	jr	__PL_return
	
	__PL_put_one_px:
		ld		A,			start_x
		ld		C,			start_y
		pop		DE
		push	DE
		call	_put_pixel

__PL_return:
	pop		BC
	pop		DE
	pop		HL
	ret
#}

%undef length

#
#1) n_decalage = 3 - 1 = 2
#	end.x - start.x = 5 (length)
#	dec_len = length/n_decalage = 2 reste 1
#
#	x = start.x, y = start.y
#	while (length)
#	{
#		tmp = dec_len
#		while (tmp && length)
#		{
#			put_pixel(x, y)
#			x++
#			length--;
#		}
#		y++ # ou y-- si n_decalage < 0
#	}

%undef X
%undef Y
%undef LENGTH
%undef COLOR
%undef SHIFT_LEN


%undef start
%undef end
%undef neg_color
%undef start_x
%undef start_y
%undef end_x
%undef end_y
%undef negative
%undef color
